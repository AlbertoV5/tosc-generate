#+title:     WebAPI
#+author:    Alberto Valdez
#+email:     avq5ac1@gmail.com
#+PROPERTY: header-args:mongo :db toscdb :host localhost :port 27017 :mongoexec mongosh :wrap example


* Pydantic to MongoDB

** Database

Because we are dealing with tree structures, we want to use a document based database like Mongodb.

So we need to store the Pydantic objects as Mongo db items. We will create a "toscdb" database that we will use for testing.

#+begin_src shell :wrap example
mongosh --eval "show dbs" | grep toscdb
#+end_src

#+RESULTS:
#+begin_example
toscdb      44.00 KiB
#+end_example

We have created a pytest mark for database tests, named "db".

#+begin_src shell :wrap example :results output
pytest -m db
#+end_src

#+RESULTS:
#+begin_example
============================= test session starts ==============================
platform darwin -- Python 3.10.6, pytest-7.1.3, pluggy-1.0.0
rootdir: /Users/albertovaldez/tosclib, configfile: pyproject.toml
plugins: sugar-0.9.5, doctestplus-0.12.1, profiling-1.7.0, cov-3.0.0
collected 10 items / 8 deselected / 2 selected

tests/test_db.py::test_database_medium PASSED                            [ 50%]
tests/test_db.py::test_database_base PASSED                              [100%]

======================= 2 passed, 8 deselected in 0.23s ========================
#+end_example

We will use a "templates" collection for storing our Templates as objects. In the mongo shell, we will check for the Template object.

#+begin_src mongo :wrap example typescript
db.test.findOne()
#+end_src

#+RESULTS:
#+begin_example typescript
toscdb> {
  _id: new UUID("69436d8f-46b0-4ca7-8b51-beff06701887"),
  lexml: {
    at_version: 3,
    node: {
      at_type: 'GROUP',
      at_ID: new UUID("69436d8f-46b0-4ca7-8b51-beff06701887"),
      properties: [ { at_type: 'r', key: 'frame', value: [ 0, 0, 400, 400 ] } ],
      values: [],
      messages: { midi: [], osc: [], local: [], gamepad: [] },
      children: []
    }
  }
}
toscdb>
#+end_example

We will construct tests for different-sized Templates.

** The Template Size Problem

Our hypothesis is that there is a point in a Template size that it becomes a problem for the database to process it and for its data to be send from one place to another.

Because of that, we propose to limit the Template depth to a certain number. This means that once we hit a certain level of recursion in the =children= -> =control= hierarchy, we will suggest to treat a Control as a different Template. This will help us fragment the data and reduce problems from heavily-nested data.

This leads us to present the project as a "Component-based" repository of Templates. Where we can combine them locally in a single Template if we want or add them as Controls to other Templates.

Our first estimation is that a recursion level of =8= would be a good limit, counting the root Control. However we will test a range from =5 to 8= and try to find the best compromise for processing requirements and comfort.


** Measurements

1. It takes about 2 seconds for parsing a 94kb template file with complex tree structures and multiple script strings. The roundtrip being 4 seconds with inserting and retrieving from the database.

* FastAPI

** CRUD

Now that the parsing, validation, connection and rountrip work, we will create endpoints for CRUD operations. We will start with simple actions.

1. Upload a Template to the database.
2. Get a Template from the database.

We need to use the Template ID or name to retrieve it from the server. So we have to figure out how are we going to relate the UUID and a name.

The UUID has to be used because that's how Templates generate their ids by default. However, for user experience, we want to have a name and author for each Template. The complete schema for a component table can be:

#+begin_src sql :eval no
CREATE TABLE component (
            id SERIAL,
            author VARCHAR(40) NOT NULL,
            name VARCHAR(40) NOT NULL,
            uuid UUID NOT NULL -- Template uuid
);
INSERT INTO template(id, author, name, uuid)
VALUES (0, 'bob', 'mytemplate', 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11');
#+end_src

This is an SQL representation but we could solve the problem with NoSQL too by adding the data to the Template object.
